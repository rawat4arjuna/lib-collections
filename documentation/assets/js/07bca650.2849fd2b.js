"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[2563],{1184:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>c});var r=n(4041);const o={},s=r.createContext(o);function a(e){const t=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),r.createElement(s.Provider,{value:t},e.children)}},5606:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>u,contentTitle:()=>c,default:()=>l,frontMatter:()=>a,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"rexora-hooks/use-rexora-latest","title":"useRexoraLatest","description":"The useRexoraLatest hook provides a way to access the most recent value of a state or prop, even from within closures that might have captured an older value. This is particularly useful in scenarios where you need to access the current value of a dependency inside effects or event handlers without adding that dependency to the dependency array, which could cause unwanted re-executions.","source":"@site/docs/rexora-hooks/use-rexora-latest.md","sourceDirName":"rexora-hooks","slug":"/rexora-hooks/use-rexora-latest","permalink":"/rexora/documentation/docs/rexora-hooks/use-rexora-latest","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"useRexoraIsomorphicLayoutEffect","permalink":"/rexora/documentation/docs/rexora-hooks/use-rexora-isomorphic-layout-effect"},"next":{"title":"useRexoraMounted","permalink":"/rexora/documentation/docs/rexora-hooks/use-rexora-mounted"}}');var o=n(1085),s=n(1184);const a={},c="useRexoraLatest",u={},d=[{value:"Functionality",id:"functionality",level:2},{value:"Parameters",id:"parameters",level:2},{value:"Returns",id:"returns",level:2},{value:"Usage Examples",id:"usage-examples",level:2}];function i(e){const t={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.header,{children:(0,o.jsx)(t.h1,{id:"userexoralatest",children:"useRexoraLatest"})}),"\n",(0,o.jsxs)(t.p,{children:["The ",(0,o.jsx)(t.code,{children:"useRexoraLatest"})," hook provides a way to access the most recent value of a state or prop, even from within closures that might have captured an older value. This is particularly useful in scenarios where you need to access the current value of a dependency inside effects or event handlers without adding that dependency to the dependency array, which could cause unwanted re-executions."]}),"\n",(0,o.jsx)(t.h2,{id:"functionality",children:"Functionality"}),"\n",(0,o.jsxs)(t.p,{children:["This hook utilizes a ",(0,o.jsx)(t.code,{children:"useRef"})," to store and update the latest value of the provided argument on every render. The hook returns the ref itself, allowing you to access the ",(0,o.jsx)(t.code,{children:".current"})," property to get the most up-to-date value."]}),"\n",(0,o.jsx)(t.h2,{id:"parameters",children:"Parameters"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.code,{children:"value"}),": The state or prop whose latest value you want to track. This can be of any type."]}),"\n"]}),"\n",(0,o.jsx)(t.h2,{id:"returns",children:"Returns"}),"\n",(0,o.jsxs)(t.p,{children:["A React ref object containing the latest value of the provided ",(0,o.jsx)(t.code,{children:"value"}),". You can access the latest value via ",(0,o.jsx)(t.code,{children:"ref.current"}),"."]}),"\n",(0,o.jsx)(t.h2,{id:"usage-examples",children:"Usage Examples"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{children:"javascript\nimport { useState, useEffect } from 'react';\nimport { useRexoraLatest } from '@@rexora/hooks/useRexoraLatest';\n\nfunction MyComponent() {\n  const [count, setCount] = useState(0);\n  const latestCount = useRexoraLatest(count);\n\n  // This effect runs only once on mount\n  useEffect(() => {\n    const intervalId = setInterval(() => {\n      // We can access the latest count here without adding 'count' to the\n      // dependency array of useEffect, avoiding unnecessary re-renders of the effect.\n      console.log('Latest count:', latestCount.current);\n    }, 1000);\n\n    return () => clearInterval(intervalId);\n  }, []); // Empty dependency array\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={() => setCount(count + 1)}>Increment</button>\n    </div>\n  );\n}\n"})}),"\n",(0,o.jsxs)(t.p,{children:["In this example, the ",(0,o.jsx)(t.code,{children:"useEffect"})," only runs once on mount. Inside the interval callback, we use ",(0,o.jsx)(t.code,{children:"latestCount.current"})," to get the current value of ",(0,o.jsx)(t.code,{children:"count"}),". If we had used ",(0,o.jsx)(t.code,{children:"count"})," directly in the ",(0,o.jsx)(t.code,{children:"setInterval"})," and added ",(0,o.jsx)(t.code,{children:"count"})," to the ",(0,o.jsx)(t.code,{children:"useEffect"})," dependency array, the interval would be cleared and re-created every time ",(0,o.jsx)(t.code,{children:"count"})," changes, which is often not the desired behavior for such use cases."]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{children:"javascript\nimport { useState } from 'react';\nimport { useRexoraLatest } from '@@rexora/hooks/useRexoraLatest';\n\nfunction AnotherComponent({ userId }) {\n  const latestUserId = useRexoraLatest(userId);\n\n  const fetchData = () => {\n    // You can access the latest userId here, e.g., for an API call\n    console.log('Fetching data for user ID:', latestUserId.current);\n    // perform API call with latestUserId.current\n  };\n\n  return (\n    <div>\n      <p>Current User ID: {userId}</p>\n      <button onClick={fetchData}>Fetch Data</button>\n    </div>\n  );\n}\n"})}),"\n",(0,o.jsxs)(t.p,{children:['In this case, when the "Fetch Data" button is clicked, the ',(0,o.jsx)(t.code,{children:"fetchData"})," function will use the most recent value of the ",(0,o.jsx)(t.code,{children:"userId"})," prop, even if the component has re-rendered with a new ",(0,o.jsx)(t.code,{children:"userId"})," value since the ",(0,o.jsx)(t.code,{children:"fetchData"})," function was defined."]})]})}function l(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(i,{...e})}):i(e)}}}]);