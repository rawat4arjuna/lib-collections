"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[9389],{618:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>i,contentTitle:()=>a,default:()=>h,frontMatter:()=>c,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"rexora-hooks/use-rexora-debounce-effect","title":"use-rexora-debounce-effect","description":"---","source":"@site/docs/rexora-hooks/use-rexora-debounce-effect.md","sourceDirName":"rexora-hooks","slug":"/rexora-hooks/use-rexora-debounce-effect","permalink":"/rexora/documentation/docs/rexora-hooks/use-rexora-debounce-effect","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"useRexoraAsync","permalink":"/rexora/documentation/docs/rexora-hooks/use-rexora-async"},"next":{"title":"useRexoraDebounce","permalink":"/rexora/documentation/docs/rexora-hooks/use-rexora-debounce"}}');var r=t(1085),o=t(1184);const c={},a=void 0,i={},d=[{value:"sidebar_position: 2",id:"sidebar_position-2",level:2},{value:"Parameters",id:"parameters",level:2},{value:"Return Value",id:"return-value",level:2},{value:"Functionality",id:"functionality",level:2},{value:"Usage",id:"usage",level:2},{value:"Notes",id:"notes",level:2}];function l(e){const n={code:"code",h1:"h1",h2:"h2",hr:"hr",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"sidebar_position-2",children:"sidebar_position: 2"}),"\n",(0,r.jsx)(n.h1,{id:"userexoradebounceeffect",children:"useRexoraDebounceEffect"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"useRexoraDebounceEffect"})," hook provides a way to debounce the execution of an effect hook. This is particularly useful when you have dependencies that change frequently and you want to avoid triggering the effect on every single change. It works by waiting for a specified delay after the dependencies have stopped changing before executing the provided callback function."]}),"\n",(0,r.jsx)(n.h2,{id:"parameters",children:"Parameters"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"useRexoraDebounceEffect"})," hook accepts the following parameters:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"callback"}),": A function that contains the effect logic. This function will be executed after the debounce delay has passed since the last dependency change."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"delay"}),": The number of milliseconds to debounce the effect execution."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"dependencies"}),": An array of values that the effect depends on. The effect will be re-evaluated when any of these values change, but the callback will be debounced."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"return-value",children:"Return Value"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"useRexoraDebounceEffect"})," hook does not return any value."]}),"\n",(0,r.jsx)(n.h2,{id:"functionality",children:"Functionality"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"useRexoraDebounceEffect"})," hook internally manages a timer. When the ",(0,r.jsx)(n.code,{children:"dependencies"})," change, the existing timer is cleared, and a new timer is set. If the ",(0,r.jsx)(n.code,{children:"delay"})," time elapses without further changes to the dependencies, the ",(0,r.jsx)(n.code,{children:"callback"})," function is executed. If the dependencies change again before the delay is over, the timer is reset. This ensures that the effect is only triggered after a period of inactivity in the dependencies."]}),"\n",(0,r.jsxs)(n.p,{children:["This hook is implemented using ",(0,r.jsx)(n.code,{children:"useEffect"})," and ",(0,r.jsx)(n.code,{children:"useRef"})," to manage the timer and persist it across renders. It also includes proper cleanup to clear the timer when the component unmounts or the effect needs to be re-evaluated."]}),"\n",(0,r.jsx)(n.h2,{id:"usage",children:"Usage"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"jsx\nimport { useRexoraDebounceEffect } from '@rexora/hooks'; \nfunction MyComponent() {\n  const [searchTerm, setSearchTerm] = useState('');\n  const [results, setResults] = useState([]);\n\n  // Debounce the search effect by 500ms\n  useRexoraDebounceEffect(\n    () => {\n      if (searchTerm) {\n        // Simulate fetching search results\n        console.log('Searching for:', searchTerm);\n        // In a real app, you would fetch data here\n        setResults([`Result for ${searchTerm}`]);\n      } else {\n        setResults([]);\n      }\n    },\n    [searchTerm],// Dependencies array\n     500 // Debounce delay in milliseconds\n  );\n\n  return (\n    <div>\n      <input\n        type=\"text\"\n        value={searchTerm}\n        onChange={(e) => setSearchTerm(e.target.value)}\n        placeholder=\"Enter search term\"\n      />\n      <ul>\n        {results.map((result, index) => (\n          <li key={index}>{result}</li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"notes",children:"Notes"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["The ",(0,r.jsx)(n.code,{children:"effectFn"})," will only execute after the specified ",(0,r.jsx)(n.code,{children:"delay"})," has passed without any changes to the ",(0,r.jsx)(n.code,{children:"dependencies"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:["If the ",(0,r.jsx)(n.code,{children:"dependencies"})," change before the delay has passed, the previous timeout will be cleared, and a new timeout will be set."]}),"\n",(0,r.jsx)(n.li,{children:"The hook ensures that event listeners and timeouts are properly managed to prevent memory leaks."}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},1184:(e,n,t)=>{t.d(n,{R:()=>c,x:()=>a});var s=t(4041);const r={},o=s.createContext(r);function c(e){const n=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:c(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);