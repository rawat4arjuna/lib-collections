"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[5613],{1184:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>c});var r=n(4041);const o={},s=r.createContext(o);function a(e){const t=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),r.createElement(s.Provider,{value:t},e.children)}},5062:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>i,contentTitle:()=>c,default:()=>u,frontMatter:()=>a,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"rexora-hooks/use-rexora-update-effect","title":"useRexoraUpdateEffect","description":"The useRexoraUpdateEffect hook is similar to React\'s built-in useEffect, but with one key difference: it does not run on the initial render of the component. It only executes the effect function when the dependencies array changes. This is useful when you need to perform side effects only in response to updates, and not when the component first mounts.","source":"@site/docs/rexora-hooks/use-rexora-update-effect.md","sourceDirName":"rexora-hooks","slug":"/rexora-hooks/use-rexora-update-effect","permalink":"/rexora/documentation/docs/rexora-hooks/use-rexora-update-effect","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"useRexoraUpdateEffect"},"sidebar":"tutorialSidebar","previous":{"title":"useRexoraToggle","permalink":"/rexora/documentation/docs/rexora-hooks/use-rexora-toggle"}}');var o=n(1085),s=n(1184);const a={title:"useRexoraUpdateEffect"},c="useRexoraUpdateEffect",i={},d=[{value:"Installation",id:"installation",level:2},{value:"Import",id:"import",level:2},{value:"Usage",id:"usage",level:2},{value:"Parameters",id:"parameters",level:2},{value:"Return Value",id:"return-value",level:2},{value:"Examples",id:"examples",level:2},{value:"Reacting to Prop Changes",id:"reacting-to-prop-changes",level:3},{value:"Performing Cleanup on Update",id:"performing-cleanup-on-update",level:3}];function l(e){const t={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.header,{children:(0,o.jsx)(t.h1,{id:"userexoraupdateeffect",children:(0,o.jsx)(t.code,{children:"useRexoraUpdateEffect"})})}),"\n",(0,o.jsxs)(t.p,{children:["The ",(0,o.jsx)(t.code,{children:"useRexoraUpdateEffect"})," hook is similar to React's built-in ",(0,o.jsx)(t.code,{children:"useEffect"}),", but with one key difference: it does not run on the initial render of the component. It only executes the effect function when the dependencies array changes. This is useful when you need to perform side effects only in response to updates, and not when the component first mounts."]}),"\n",(0,o.jsx)(t.h2,{id:"installation",children:"Installation"}),"\n",(0,o.jsx)(t.p,{children:"This hook is part of the Rexora hooks package."}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{children:"bash\nnpm install @rexora/hooks\n# or\nyarn add @rexora/hooks\n"})}),"\n",(0,o.jsx)(t.h2,{id:"import",children:"Import"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{children:"typescript\nimport { useRexoraUpdateEffect } from '@rexora/hooks';\n"})}),"\n",(0,o.jsx)(t.h2,{id:"usage",children:"Usage"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{children:"typescript\nimport React, { useState } from 'react';\nimport { useRexoraUpdateEffect } from '@rexora/hooks';\n\nfunction MyComponent() {\n  const [count, setCount] = useState(0);\n\n  useRexoraUpdateEffect(() => {\n    console.log('Count has been updated:', count);\n    // Perform side effect based on count change\n  }, [count]); // Effect runs only when count changes, not on initial render\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={() => setCount(count + 1)}>Increment</button>\n    </div>\n  );\n}\n"})}),"\n",(0,o.jsx)(t.h2,{id:"parameters",children:"Parameters"}),"\n",(0,o.jsxs)(t.table,{children:[(0,o.jsx)(t.thead,{children:(0,o.jsxs)(t.tr,{children:[(0,o.jsx)(t.th,{style:{textAlign:"left"},children:"Parameter"}),(0,o.jsx)(t.th,{style:{textAlign:"left"},children:"Type"}),(0,o.jsx)(t.th,{style:{textAlign:"left"},children:"Description"})]})}),(0,o.jsxs)(t.tbody,{children:[(0,o.jsxs)(t.tr,{children:[(0,o.jsx)(t.td,{style:{textAlign:"left"},children:(0,o.jsx)(t.code,{children:"effect"})}),(0,o.jsx)(t.td,{style:{textAlign:"left"},children:(0,o.jsx)(t.code,{children:"() => void | (() => void)"})}),(0,o.jsx)(t.td,{style:{textAlign:"left"},children:"The function to run as the side effect. Can optionally return a cleanup function."})]}),(0,o.jsxs)(t.tr,{children:[(0,o.jsx)(t.td,{style:{textAlign:"left"},children:(0,o.jsx)(t.code,{children:"dependencies"})}),(0,o.jsx)(t.td,{style:{textAlign:"left"},children:(0,o.jsx)(t.code,{children:"React.DependencyList"})}),(0,o.jsx)(t.td,{style:{textAlign:"left"},children:"An array of values that the effect depends on. The effect will re-run when any of these values change."})]})]})]}),"\n",(0,o.jsx)(t.h2,{id:"return-value",children:"Return Value"}),"\n",(0,o.jsx)(t.p,{children:"This hook does not return any value."}),"\n",(0,o.jsx)(t.h2,{id:"examples",children:"Examples"}),"\n",(0,o.jsx)(t.h3,{id:"reacting-to-prop-changes",children:"Reacting to Prop Changes"}),"\n",(0,o.jsxs)(t.p,{children:["You can use ",(0,o.jsx)(t.code,{children:"useRexoraUpdateEffect"})," to react specifically to changes in component props."]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{children:"typescript\nimport React, { useState } from 'react';\nimport { useRexoraUpdateEffect } from '@rexora/hooks';\n\nfunction UserProfile({ userId }) {\n  const [userData, setUserData] = useState(null);\n\n  useRexoraUpdateEffect(() => {\n    console.log('Fetching data for new user:', userId);\n    // Simulate fetching user data\n    const fetchUserData = async () => {\n      // Replace with actual data fetching logic\n      const data = { id: userId, name: `User ${userId}` };\n      setUserData(data);\n    };\n    fetchUserData();\n  }, [userId]); // Effect runs only when userId prop changes\n\n  return (\n    <div>\n      {userData ? (\n        <p>User ID: {userData.id}, Name: {userData.name}</p>\n      ) : (\n        <p>Loading user data...</p>\n      )}\n    </div>\n  );\n}\n"})}),"\n",(0,o.jsx)(t.h3,{id:"performing-cleanup-on-update",children:"Performing Cleanup on Update"}),"\n",(0,o.jsxs)(t.p,{children:["Similar to ",(0,o.jsx)(t.code,{children:"useEffect"}),", you can return a cleanup function from the effect callback. This function will run before the effect is re-run and when the component unmounts."]})]})}function u(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}}}]);